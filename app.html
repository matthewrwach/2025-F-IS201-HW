<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solitaire - Card Game</title>
    <link rel="stylesheet" href="styles/professional.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
            min-height: 100vh;
            padding: 0;
        }

        .game-container {
            background-color: #fff;
            border-radius: 10px;
            padding: 30px;
            max-width: 1200px;
            margin: 2rem auto;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 20px;
            font-size: 2.5rem;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
        }

        .score-display {
            font-size: 1.2rem;
            color: #2c3e50;
            display: flex;
            gap: 20px;
        }

        .score-display span {
            color: #3498db;
            font-weight: bold;
        }

        .game-buttons {
            display: flex;
            gap: 10px;
        }

        button {
            padding: 10px 20px;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            background-color: #3498db;
            color: #fff;
        }

        button:hover {
            background-color: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .game-board {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 8px;
            padding: 30px;
            min-height: 600px;
            position: relative;
        }

        .top-section {
            display: flex;
            justify-content: space-between;
            margin-bottom: 40px;
        }

        .stock-waste {
            display: flex;
            gap: 15px;
        }

        .foundations {
            display: flex;
            gap: 15px;
        }

        .pile {
            width: 80px;
            height: 112px;
            border: 2px dashed rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            background-color: rgba(255, 255, 255, 0.1);
            position: relative;
            cursor: pointer;
            transition: all 0.3s;
        }

        .pile:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }

        .pile.has-cards {
            border: 2px solid rgba(255, 255, 255, 0.8);
            background-color: transparent;
        }

        #waste {
            width: 240px;
            min-height: 112px;
            height: 112px;
            overflow: visible;
        }

        #waste .card {
            position: absolute;
            top: 0;
        }

        .card {
            width: 80px;
            height: 112px;
            background-color: #fff;
            border-radius: 6px;
            border: 1px solid #ddd;
            position: absolute;
            cursor: grab;
            user-select: none;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            opacity: 1;
            backface-visibility: hidden;
        }

        .card:active {
            cursor: grabbing;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .card.face-down {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            background-image: 
                repeating-linear-gradient(45deg, transparent, transparent 10px, rgba(0,0,0,0.1) 10px, rgba(0,0,0,0.1) 20px);
        }

        .card.face-up {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 6px;
        }

        .card.red {
            color: #e74c3c;
        }

        .card.black {
            color: #2c3e50;
        }

        .card-rank {
            font-size: 16px;
            font-weight: bold;
            line-height: 1;
        }

        .card-suit {
            font-size: 28px;
            text-align: center;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .card-rank-bottom {
            font-size: 16px;
            font-weight: bold;
            line-height: 1;
            transform: rotate(180deg);
            text-align: right;
        }

        .tableau {
            display: flex;
            gap: 15px;
            margin-top: 30px;
        }

        .tableau-pile {
            width: 80px;
            min-height: 112px;
            position: relative;
            isolation: isolate;
        }

        .tableau-pile .card {
            position: absolute;
            top: 0;
            left: 0;
            background-color: #fff;
        }

        .tableau-pile .card:not(:first-child) {
            margin-top: 25px;
        }

        .card.selected {
            border: 3px solid #f39c12;
            transform: translateY(-10px);
            z-index: 1000;
            box-shadow: 0 6px 16px rgba(243, 156, 18, 0.5);
        }

        .card.dragging {
            opacity: 0.9;
            z-index: 999999 !important;
            transform: rotate(2deg) scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
            pointer-events: none;
        }
        
        #gameBoard {
            position: relative;
        }

        .card.valid-drop {
            border: 3px solid #27ae60;
        }

        .message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(44, 62, 80, 0.95);
            color: #fff;
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 2000;
            border: 3px solid #3498db;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .message h2 {
            margin-bottom: 15px;
            font-size: 2rem;
            color: #3498db;
        }

        .message p {
            margin: 10px 0;
            font-size: 1.2rem;
        }

        .message button {
            margin-top: 20px;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        button:disabled:hover {
            background-color: #4a7c59;
            transform: none;
        }
    </style>
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <div class="nav-logo">Portfolio</div>
            <ul class="nav-menu">
                <li><a href="index.html" class="nav-link">Home</a></li>
                <li><a href="resume.html" class="nav-link">Resume</a></li>
                <li><a href="scratch.html" class="nav-link">Scratch Page</a></li>
                <li><a href="app.html" class="nav-link active">Web App</a></li>
            </ul>
        </div>
    </nav>
    <div class="game-container">
        <h1>Solitaire</h1>
        <div class="game-info">
            <div class="score-display">
                <div>Score: <span id="score">0</span></div>
                <div>Moves: <span id="moves">0</span></div>
                <div>Time: <span id="timer">0:00</span></div>
                <div>High Score: <span id="highScore">0</span></div>
            </div>
            <div class="game-buttons">
                <button onclick="undoMove()" id="undoBtn" disabled>Undo</button>
                <button onclick="newGame()">New Game</button>
                <button onclick="hint()">Hint</button>
            </div>
        </div>
        
        <div class="game-board" id="gameBoard">
            <div class="top-section">
                <div class="stock-waste">
                    <div class="pile" id="stock" onclick="drawCard()"></div>
                    <div class="pile" id="waste"></div>
                </div>
                <div class="foundations">
                    <div class="pile" id="foundation-0"></div>
                    <div class="pile" id="foundation-1"></div>
                    <div class="pile" id="foundation-2"></div>
                    <div class="pile" id="foundation-3"></div>
                </div>
            </div>
            <div class="tableau" id="tableau"></div>
        </div>
    </div>

    <div class="message" id="winMessage">
        <h2>Congratulations!</h2>
        <p>You won the game!</p>
        <p>Final Score: <span id="finalScore">0</span></p>
        <button onclick="newGame()">Play Again</button>
    </div>

    <script>
        const suits = ['♠', '♥', '♦', '♣'];
        const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
        const suitColors = { '♠': 'black', '♥': 'red', '♦': 'red', '♣': 'black' };

        let deck = [];
        let stock = [];
        let waste = [];
        let foundations = [[], [], [], []];
        let tableau = [[], [], [], [], [], [], []];
        let selectedCard = null;
        let selectedPile = null;
        let draggedCard = null;
        let dragOffset = { x: 0, y: 0 };
        let moves = 0;
        let score = 0;
        let moveHistory = [];
        let maxHistorySize = 50;
        let highScore = localStorage.getItem('solitaireHighScore') || 0;
        let gameStartTime = null;
        let timerInterval = null;
        let elapsedSeconds = 0;

        function createDeck() {
            const newDeck = [];
            for (let suit of suits) {
                for (let rank of ranks) {
                    newDeck.push({
                        suit: suit,
                        rank: rank,
                        value: ranks.indexOf(rank) + 1,
                        color: suitColors[suit],
                        id: Math.random().toString(36).substr(2, 9)
                    });
                }
            }
            return shuffle(newDeck);
        }

        function shuffle(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function newGame() {
            // Stop existing timer
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }

            deck = createDeck();
            stock = [];
            waste = [];
            foundations = [[], [], [], []];
            tableau = [[], [], [], [], [], [], []];
            selectedCard = null;
            selectedPile = null;
            draggedCard = null;
            moves = 0;
            score = 0;
            moveHistory = [];
            elapsedSeconds = 0;
            gameStartTime = null;

            // Deal to tableau
            for (let i = 0; i < 7; i++) {
                for (let j = 0; j <= i; j++) {
                    const card = deck.pop();
                    if (j === i) {
                        card.faceUp = true;
                    } else {
                        card.faceUp = false;
                    }
                    tableau[i].push(card);
                }
            }

            // Remaining cards go to stock
            stock = deck;

            updateDisplay();
            updateScore();
            updateTimer();
            updateUndoButton();
            document.getElementById('winMessage').style.display = 'none';
        }

        function startTimer() {
            if (!gameStartTime && !timerInterval) {
                gameStartTime = Date.now() - (elapsedSeconds * 1000);
                timerInterval = setInterval(updateTimer, 1000);
            }
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function updateTimer() {
            if (gameStartTime) {
                elapsedSeconds = Math.floor((Date.now() - gameStartTime) / 1000);
            }
            
            const minutes = Math.floor(elapsedSeconds / 60);
            const seconds = elapsedSeconds % 60;
            const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('timer').textContent = timeString;
        }

        function drawCard() {
            startTimer(); // Start timer on first action
            
            let action = null;
            if (stock.length === 0 && waste.length > 0) {
                // Recycle waste back to stock
                action = {
                    type: 'recycle',
                    stock: [...stock],
                    waste: [...waste]
                };
                stock = waste.reverse();
                waste = [];
                stock.forEach(card => card.faceUp = false);
            } else if (stock.length > 0) {
                const card = stock.pop();
                action = {
                    type: 'draw',
                    card: card,
                    stock: [...stock],
                    waste: [...waste]
                };
                card.faceUp = true;
                waste.push(card);
            }
            
            if (action) {
                saveMove(action);
                moves++;
                updateScore();
                updateDisplay();
                updateUndoButton();
            }
        }

        function createCardElement(card, index = 0, pileType = '', pileIndex = -1) {
            const cardEl = document.createElement('div');
            cardEl.className = `card ${card.color} ${card.faceUp ? 'face-up' : 'face-down'}`;
            cardEl.dataset.cardId = card.id;
            cardEl.dataset.pileType = pileType;
            cardEl.dataset.pileIndex = pileIndex;
            // Higher index = higher z-index (card on top)
            cardEl.style.zIndex = index + 10;

            if (card.faceUp) {
                cardEl.innerHTML = `
                    <div class="card-rank">${card.rank}</div>
                    <div class="card-suit">${card.suit}</div>
                    <div class="card-rank-bottom">${card.rank}</div>
                `;
            }

            // Add drag functionality
            cardEl.addEventListener('mousedown', (e) => {
                if (card.faceUp) {
                    startTimer(); // Start timer on first action
                    
                    // For waste pile, only allow dragging the top card
                    if (pileType === 'waste' && pileIndex === -1) {
                        if (waste.length > 0 && waste[waste.length - 1].id !== card.id) {
                            return; // Not the top card, don't allow drag
                        }
                    }
                    startDrag(e, card, cardEl, pileType, pileIndex);
                }
            });

            return cardEl;
        }

        function startDrag(e, card, cardEl, pileType, pileIndex) {
            e.preventDefault();
            draggedCard = card;
            draggedCard.element = cardEl;
            draggedCard.pileType = pileType;
            draggedCard.pileIndex = pileIndex;

            const rect = cardEl.getBoundingClientRect();
            dragOffset.x = e.clientX - rect.left;
            dragOffset.y = e.clientY - rect.top;

            // Move card to body level to break out of stacking contexts
            const gameBoard = document.getElementById('gameBoard');
            const originalParent = cardEl.parentElement;
            gameBoard.appendChild(cardEl);

            cardEl.classList.add('dragging');
            cardEl.style.position = 'fixed';
            cardEl.style.left = e.clientX - dragOffset.x + 'px';
            cardEl.style.top = e.clientY - dragOffset.y + 'px';
            cardEl.style.zIndex = '999999';
            cardEl.style.pointerEvents = 'none';
            cardEl.style.width = rect.width + 'px';
            cardEl.style.height = rect.height + 'px';

            // Store original parent to restore later
            draggedCard.originalParent = originalParent;

            document.addEventListener('mousemove', onDrag);
            document.addEventListener('mouseup', endDrag);
        }

        function onDrag(e) {
            if (!draggedCard) return;

            draggedCard.element.style.left = e.clientX - dragOffset.x + 'px';
            draggedCard.element.style.top = e.clientY - dragOffset.y + 'px';

            // Highlight valid drop zones
            const elementBelow = document.elementFromPoint(e.clientX, e.clientY);
            if (elementBelow) {
                document.querySelectorAll('.pile, .tableau-pile').forEach(pile => {
                    pile.classList.remove('valid-drop');
                });

                const pile = elementBelow.closest('.pile, .tableau-pile');
                if (pile) {
                    const targetPile = getPileFromElement(pile);
                    if (targetPile && canMove(draggedCard, { type: draggedCard.pileType, index: draggedCard.pileIndex }, targetPile)) {
                        pile.classList.add('valid-drop');
                    }
                }
            }
        }

        function endDrag(e) {
            if (!draggedCard) return;

            const elementBelow = document.elementFromPoint(e.clientX, e.clientY);
            let dropped = false;

            if (elementBelow) {
                const pile = elementBelow.closest('.pile, .tableau-pile');
                if (pile) {
                    const targetPile = getPileFromElement(pile);
                    if (targetPile) {
                        // Re-find the card in the current state (in case it changed)
                        const currentCard = findCardById(draggedCard.id);
                        if (currentCard) {
                            const fromPile = findPile(currentCard);
                            if (fromPile && canMove(currentCard, fromPile, targetPile)) {
                                moveCard(currentCard, fromPile, targetPile);
                                dropped = true;
                            }
                        }
                    }
                }
            }

            // Reset card position and restore to original parent
            if (draggedCard.element) {
                draggedCard.element.classList.remove('dragging');
                draggedCard.element.style.position = '';
                draggedCard.element.style.left = '';
                draggedCard.element.style.top = '';
                draggedCard.element.style.pointerEvents = '';
                draggedCard.element.style.zIndex = '';
                draggedCard.element.style.width = '';
                draggedCard.element.style.height = '';
                
                // Restore to original parent if not dropped
                if (!dropped && draggedCard.originalParent) {
                    draggedCard.originalParent.appendChild(draggedCard.element);
                }
            }

            document.querySelectorAll('.pile, .tableau-pile').forEach(pile => {
                pile.classList.remove('valid-drop');
            });

            document.removeEventListener('mousemove', onDrag);
            document.removeEventListener('mouseup', endDrag);

            if (!dropped) {
                updateDisplay();
            }

            draggedCard = null;
        }

        function findCardById(cardId) {
            // Check waste
            const wasteCard = waste.find(c => c.id === cardId);
            if (wasteCard) return wasteCard;
            
            // Check foundations
            for (let foundation of foundations) {
                const card = foundation.find(c => c.id === cardId);
                if (card) return card;
            }
            
            // Check tableau
            for (let pile of tableau) {
                const card = pile.find(c => c.id === cardId);
                if (card) return card;
            }
            
            return null;
        }

        function getPileFromElement(element) {
            if (!element) return null;

            if (element.id === 'waste') return { type: 'waste', index: -1 };
            if (element.id === 'stock') return null;
            if (element.id.startsWith('foundation-')) {
                return { type: 'foundation', index: parseInt(element.id.split('-')[1]) };
            }
            if (element.classList.contains('tableau-pile')) {
                const index = Array.from(element.parentElement.children).indexOf(element);
                return { type: 'tableau', index: index };
            }
            if (element.classList.contains('pile') && element.id.startsWith('foundation-')) {
                return { type: 'foundation', index: parseInt(element.id.split('-')[1]) };
            }
            return null;
        }

        function findPile(card) {
            // Check waste
            if (waste.includes(card)) return { type: 'waste', index: -1 };
            
            // Check foundations
            for (let i = 0; i < foundations.length; i++) {
                if (foundations[i].includes(card)) return { type: 'foundation', index: i };
            }
            
            // Check tableau
            for (let i = 0; i < tableau.length; i++) {
                if (tableau[i].includes(card)) return { type: 'tableau', index: i };
            }
            
            return null;
        }

        function canMove(card, fromPile, toPile) {
            if (!toPile || !fromPile || !card) return false;

            // Can't move to the same pile
            if (fromPile.type === toPile.type && fromPile.index === toPile.index) {
                return false;
            }

            // Verify card is actually in the fromPile
            let cardInPile = false;
            if (fromPile.type === 'waste') {
                // For waste, only allow moving the top card (last card in array)
                cardInPile = waste.length > 0 && waste[waste.length - 1].id === card.id;
            } else if (fromPile.type === 'foundation') {
                cardInPile = foundations[fromPile.index].includes(card);
            } else if (fromPile.type === 'tableau') {
                cardInPile = tableau[fromPile.index].includes(card);
            }
            
            if (!cardInPile) return false;

            // Card must be face up
            if (!card.faceUp) return false;

            // Moving to foundation
            if (toPile.type === 'foundation') {
                const foundation = foundations[toPile.index];
                if (foundation.length === 0) {
                    return card.rank === 'A';
                }
                const topCard = foundation[foundation.length - 1];
                return card.suit === topCard.suit && card.value === topCard.value + 1;
            }

            // Moving to tableau
            if (toPile.type === 'tableau') {
                const targetPile = tableau[toPile.index];
                if (targetPile.length === 0) {
                    return card.rank === 'K';
                }
                const topCard = targetPile[targetPile.length - 1];
                if (!topCard.faceUp) return false;
                return card.color !== topCard.color && card.value === topCard.value - 1;
            }

            return false;
        }

        function saveMove(action) {
            const state = {
                stock: JSON.parse(JSON.stringify(stock)),
                waste: JSON.parse(JSON.stringify(waste)),
                foundations: JSON.parse(JSON.stringify(foundations)),
                tableau: JSON.parse(JSON.stringify(tableau)),
                score: score,
                moves: moves,
                action: action
            };
            moveHistory.push(state);
            if (moveHistory.length > maxHistorySize) {
                moveHistory.shift();
            }
        }

        function undoMove() {
            if (moveHistory.length === 0) return;

            const previousState = moveHistory.pop();
            stock = previousState.stock;
            waste = previousState.waste;
            foundations = previousState.foundations;
            tableau = previousState.tableau;
            score = previousState.score;
            moves = previousState.moves;

            updateDisplay();
            updateScore();
            updateUndoButton();
        }

        function updateUndoButton() {
            const undoBtn = document.getElementById('undoBtn');
            undoBtn.disabled = moveHistory.length === 0;
        }

        function moveCard(card, fromPile, toPile) {
            startTimer(); // Start timer on first action
            moveCardDirect(card, fromPile, toPile, true);
            
            updateScore();
            updateDisplay();
            updateUndoButton();
            
            // Check if all cards are revealed and auto-complete
            setTimeout(() => {
                if (areAllCardsRevealed() && stock.length === 0) {
                    autoComplete();
                }
                checkWin();
            }, 100);
        }

        function updateDisplay() {
            // Clear board
            document.getElementById('stock').innerHTML = '';
            document.getElementById('waste').innerHTML = '';
            for (let i = 0; i < 4; i++) {
                document.getElementById(`foundation-${i}`).innerHTML = '';
            }
            document.getElementById('tableau').innerHTML = '';

            // Draw stock
            if (stock.length > 0) {
                const stockCard = createCardElement({ faceUp: false, id: 'stock', color: 'black' }, 0, 'stock', -1);
                stockCard.style.background = 'linear-gradient(135deg, #2c3e50 0%, #34495e 100%)';
                stockCard.style.backgroundImage = 'repeating-linear-gradient(45deg, transparent, transparent 10px, rgba(0,0,0,0.1) 10px, rgba(0,0,0,0.1) 20px)';
                stockCard.style.cursor = 'pointer';
                document.getElementById('stock').appendChild(stockCard);
                document.getElementById('stock').classList.add('has-cards');
            } else {
                document.getElementById('stock').classList.remove('has-cards');
            }

            // Draw waste - show last 3 cards
            const wastePile = document.getElementById('waste');
            wastePile.innerHTML = '';
            if (waste.length > 0) {
                const visibleCards = waste.slice(-3); // Last 3 cards
                visibleCards.forEach((card, index) => {
                    const cardEl = createCardElement(card, waste.length - visibleCards.length + index, 'waste', -1);
                    // Stack cards with offset - each card offset by 20px
                    cardEl.style.left = (index * 20) + 'px';
                    cardEl.style.zIndex = (waste.length - visibleCards.length + index) + 10;
                    wastePile.appendChild(cardEl);
                });
                // Adjust width to show all cards
                wastePile.style.width = (80 + (visibleCards.length - 1) * 20) + 'px';
                wastePile.classList.add('has-cards');
            } else {
                wastePile.style.width = '80px';
                wastePile.classList.remove('has-cards');
            }

            // Draw foundations
            for (let i = 0; i < 4; i++) {
                const foundation = foundations[i];
                if (foundation.length > 0) {
                    const topCard = foundation[foundation.length - 1];
                    const cardEl = createCardElement(topCard, foundation.length, 'foundation', i);
                    document.getElementById(`foundation-${i}`).appendChild(cardEl);
                    document.getElementById(`foundation-${i}`).classList.add('has-cards');
                } else {
                    document.getElementById(`foundation-${i}`).classList.remove('has-cards');
                }
            }

            // Draw tableau
            for (let i = 0; i < 7; i++) {
                const pileDiv = document.createElement('div');
                pileDiv.className = 'tableau-pile';
                pileDiv.id = `tableau-${i}`;

                const pile = tableau[i];
                pile.forEach((card, index) => {
                    // Higher index cards should have higher z-index
                    const cardEl = createCardElement(card, index, 'tableau', i);
                    // Position cards stacked on top of each other
                    cardEl.style.top = (index * 25) + 'px';
                    cardEl.style.left = '0px';
                    // Ensure each card has proper z-index within its pile
                    cardEl.style.zIndex = (i * 100) + index + 10;
                    // Ensure background is solid
                    if (card.faceUp) {
                        cardEl.style.backgroundColor = '#fff';
                    }
                    pileDiv.appendChild(cardEl);
                });

                // Set pile height based on number of cards
                if (pile.length > 0) {
                    pileDiv.style.height = (112 + (pile.length - 1) * 25) + 'px';
                }

                document.getElementById('tableau').appendChild(pileDiv);
            }
        }

        function updateScore() {
            document.getElementById('moves').textContent = moves;
            document.getElementById('score').textContent = score;
            
            // Update high score if current score is higher
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('solitaireHighScore', highScore);
            }
            
            document.getElementById('highScore').textContent = highScore;
        }

        function areAllCardsRevealed() {
            // Check stock - should be empty or all face down (which is fine)
            // Check waste - all should be face up (they are when drawn)
            for (let card of waste) {
                if (!card.faceUp) return false;
            }
            
            // Check tableau - all cards should be face up
            for (let pile of tableau) {
                for (let card of pile) {
                    if (!card.faceUp) return false;
                }
            }
            
            // Check foundations - all should be face up (they are when moved)
            for (let foundation of foundations) {
                for (let card of foundation) {
                    if (!card.faceUp) return false;
                }
            }
            
            return true;
        }

        function autoComplete() {
            // Move all cards from tableau and waste to foundations
            let moved = true;
            let iterations = 0;
            const maxIterations = 52; // Safety limit
            
            while (moved && iterations < maxIterations) {
                iterations++;
                moved = false;
                
                // Try to move cards from tableau to foundations
                for (let i = 0; i < tableau.length; i++) {
                    const pile = tableau[i];
                    if (pile.length > 0) {
                        const topCard = pile[pile.length - 1];
                        if (topCard.faceUp) {
                            for (let j = 0; j < 4; j++) {
                                const fromPile = { type: 'tableau', index: i };
                                const toPile = { type: 'foundation', index: j };
                                if (canMove(topCard, fromPile, toPile)) {
                                    // Direct move without saving to history for auto-complete
                                    moveCardDirect(topCard, fromPile, toPile, false);
                                    moved = true;
                                    break;
                                }
                            }
                        }
                    }
                }
                
                // Try to move cards from waste to foundations
                if (waste.length > 0) {
                    const topCard = waste[waste.length - 1];
                    for (let j = 0; j < 4; j++) {
                        const fromPile = { type: 'waste', index: -1 };
                        const toPile = { type: 'foundation', index: j };
                        if (canMove(topCard, fromPile, toPile)) {
                            // Direct move without saving to history for auto-complete
                            moveCardDirect(topCard, fromPile, toPile, false);
                            moved = true;
                            break;
                        }
                    }
                }
                
                // Small delay to allow UI to update
                if (moved) {
                    updateDisplay();
                }
            }
            
            // Final update
            updateScore();
            updateDisplay();
        }

        function moveCardDirect(card, fromPile, toPile, saveHistory = true) {
            // Verify card still exists in fromPile before moving
            let cardExists = false;
            let cardsToMove = [card];
            
            if (fromPile.type === 'waste') {
                cardExists = waste.includes(card);
            } else if (fromPile.type === 'foundation') {
                cardExists = foundations[fromPile.index].includes(card);
            } else if (fromPile.type === 'tableau') {
                const pileIndex = tableau[fromPile.index].findIndex(c => c.id === card.id);
                cardExists = pileIndex !== -1;
                if (cardExists) {
                    cardsToMove = tableau[fromPile.index].slice(pileIndex);
                }
            }
            
            if (!cardExists) return;

            // Save state before move (only if requested)
            if (saveHistory) {
                const action = {
                    type: 'move',
                    card: card,
                    cardsToMove: cardsToMove.map(c => c.id),
                    fromPile: JSON.parse(JSON.stringify(fromPile)),
                    toPile: JSON.parse(JSON.stringify(toPile)),
                    stock: JSON.parse(JSON.stringify(stock)),
                    waste: JSON.parse(JSON.stringify(waste)),
                    foundations: JSON.parse(JSON.stringify(foundations)),
                    tableau: JSON.parse(JSON.stringify(tableau))
                };
                saveMove(action);
            }

            // Remove from source
            if (fromPile.type === 'waste') {
                const cardIndex = waste.findIndex(c => c.id === card.id);
                if (cardIndex !== -1) {
                    waste.splice(cardIndex, 1);
                }
            } else if (fromPile.type === 'foundation') {
                foundations[fromPile.index] = foundations[fromPile.index].filter(c => c.id !== card.id);
            } else if (fromPile.type === 'tableau') {
                const pileIndex = tableau[fromPile.index].findIndex(c => c.id === card.id);
                if (pileIndex !== -1) {
                    tableau[fromPile.index] = tableau[fromPile.index].slice(0, pileIndex);
                    if (tableau[fromPile.index].length > 0) {
                        const topCard = tableau[fromPile.index][tableau[fromPile.index].length - 1];
                        if (!topCard.faceUp) {
                            topCard.faceUp = true;
                            score += 5;
                        }
                    }
                }
            }

            // Add to destination
            if (toPile.type === 'tableau') {
                tableau[toPile.index].push(...cardsToMove);
                score += 5 * cardsToMove.length;
            } else if (toPile.type === 'foundation') {
                foundations[toPile.index].push(card);
                score += 10;
            }

            if (saveHistory) {
                moves++;
            }
        }

        function checkWin() {
            // Check if all cards are revealed, then auto-complete
            if (areAllCardsRevealed() && stock.length === 0) {
                // All cards are revealed, auto-complete
                autoComplete();
            }
            
            let allFoundationsFull = true;
            for (let foundation of foundations) {
                if (foundation.length !== 13) {
                    allFoundationsFull = false;
                    break;
                }
            }

            if (allFoundationsFull) {
                stopTimer(); // Stop timer when game is won
                document.getElementById('finalScore').textContent = score;
                document.getElementById('winMessage').style.display = 'block';
            }
        }

        function hint() {
            const hints = [];

            // Check waste pile to foundations
            if (waste.length > 0) {
                const topCard = waste[waste.length - 1];
                for (let j = 0; j < 4; j++) {
                    const fromPile = { type: 'waste', index: -1 };
                    const toPile = { type: 'foundation', index: j };
                    if (canMove(topCard, fromPile, toPile)) {
                        hints.push({
                            priority: 1,
                            message: `Move ${topCard.rank}${topCard.suit} from waste pile to foundation ${j + 1}`
                        });
                    }
                }
            }

            // Check tableau to foundations (high priority)
            for (let i = 0; i < tableau.length; i++) {
                const pile = tableau[i];
                if (pile.length > 0) {
                    const topCard = pile[pile.length - 1];
                    if (topCard.faceUp) {
                        for (let j = 0; j < 4; j++) {
                            const fromPile = { type: 'tableau', index: i };
                            const toPile = { type: 'foundation', index: j };
                            if (canMove(topCard, fromPile, toPile)) {
                                hints.push({
                                    priority: 1,
                                    message: `Move ${topCard.rank}${topCard.suit} from tableau pile ${i + 1} to foundation ${j + 1}`
                                });
                            }
                        }
                    }
                }
            }

            // Check waste to tableau
            if (waste.length > 0) {
                const topCard = waste[waste.length - 1];
                for (let j = 0; j < 7; j++) {
                    const fromPile = { type: 'waste', index: -1 };
                    const toPile = { type: 'tableau', index: j };
                    if (canMove(topCard, fromPile, toPile)) {
                        hints.push({
                            priority: 2,
                            message: `Move ${topCard.rank}${topCard.suit} from waste pile to tableau pile ${j + 1}`
                        });
                    }
                }
            }

            // Check tableau to tableau moves
            for (let i = 0; i < tableau.length; i++) {
                const pile = tableau[i];
                if (pile.length > 0) {
                    const topCard = pile[pile.length - 1];
                    if (topCard.faceUp) {
                        for (let j = 0; j < 7; j++) {
                            if (i !== j) {
                                const fromPile = { type: 'tableau', index: i };
                                const toPile = { type: 'tableau', index: j };
                                if (canMove(topCard, fromPile, toPile)) {
                                    hints.push({
                                        priority: 3,
                                        message: `Move ${topCard.rank}${topCard.suit} from tableau pile ${i + 1} to tableau pile ${j + 1}`
                                    });
                                }
                            }
                        }
                    }
                }
            }

            // Check for cards that can be flipped
            for (let i = 0; i < tableau.length; i++) {
                const pile = tableau[i];
                if (pile.length > 0) {
                    const topCard = pile[pile.length - 1];
                    if (!topCard.faceUp) {
                        hints.push({
                            priority: 4,
                            message: `Flip the face-down card in tableau pile ${i + 1} by moving the card above it`
                        });
                    }
                }
            }

            // Sort hints by priority (lower number = higher priority)
            hints.sort((a, b) => a.priority - b.priority);

            if (hints.length > 0) {
                alert(hints[0].message);
            } else {
                // Check if we should draw a card
                if (stock.length > 0 || (stock.length === 0 && waste.length > 0)) {
                    alert('Hint: Try drawing a card from the stock pile');
                } else {
                    alert('No moves available. You may need to undo some moves or start a new game.');
                }
            }
        }

        // Initialize high score display
        document.getElementById('highScore').textContent = highScore;
        
        // Initialize game
        newGame();
    </script>
    <footer class="footer">
        <div class="container">
            <p>&copy; 2025 Portfolio. All rights reserved.</p>
        </div>
    </footer>
</body>
</html>
